#!/usr/bin/env python3
"""
Quick Start Script - Hybrid Search com Qdrant 1.8.0
Configura e executa sistema de busca h√≠brida em minutos
"""

import asyncio
import logging
import sys
from pathlib import Path
import os

# Adicionar src ao path
sys.path.append(str(Path(__file__).parent.parent))

from src.retrieval.hybrid_indexing_pipeline import HybridIndexingPipeline
from src.retrieval.hybrid_retriever import HybridRetriever

# Configurar logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class HybridSearchQuickStart:
    """
    Quick start para sistema de busca h√≠brida
    """
    
    def __init__(self):
        self.indexing_pipeline = None
        self.retriever = None
        
    async def setup_system(self):
        """
        Configura sistema h√≠brido
        """
        print("üöÄ Configurando Sistema de Busca H√≠brida")
        print("=" * 50)
        
        # Verificar configura√ß√µes
        await self._check_requirements()
        
        # Inicializar componentes
        print("üì¶ Inicializando componentes...")
        self.indexing_pipeline = HybridIndexingPipeline()
        self.retriever = HybridRetriever()
        
        print("‚úÖ Sistema configurado!")
        
    async def _check_requirements(self):
        """
        Verifica requisitos do sistema
        """
        print("üîç Verificando requisitos...")
        
        # Verificar API keys
        required_env_vars = ["OPENAI_API_KEY"]
        missing_vars = []
        
        for var in required_env_vars:
            if not os.getenv(var):
                missing_vars.append(var)
        
        if missing_vars:
            print("‚ùå Vari√°veis de ambiente faltando:")
            for var in missing_vars:
                print(f"   - {var}")
            print("\nüí° Configure as vari√°veis antes de continuar:")
            print("   export OPENAI_API_KEY='sua_key_aqui'")
            sys.exit(1)
        
        # Verificar diret√≥rios
        config_dir = Path("config")
        if not config_dir.exists():
            config_dir.mkdir(parents=True)
            print("üìÅ Criado diret√≥rio config/")
        
        data_dir = Path("data")
        if not data_dir.exists():
            data_dir.mkdir(parents=True)
            print("üìÅ Criado diret√≥rio data/")
        
        print("‚úÖ Requisitos verificados!")
    
    async def quick_demo(self):
        """
        Demonstra√ß√£o r√°pida do sistema
        """
        print("\nüéØ Executando Demonstra√ß√£o R√°pida")
        print("=" * 40)
        
        # Criar documentos de exemplo
        await self._create_sample_docs()
        
        # Indexar documentos
        await self._quick_indexing()
        
        # Testar buscas
        await self._test_searches()
        
    async def _create_sample_docs(self):
        """
        Cria documentos de exemplo
        """
        print("üìÑ Criando documentos de exemplo...")
        
        sample_docs = {
            "rag_basics.txt": """
            RAG (Retrieval-Augmented Generation) √© uma t√©cnica que combina recupera√ß√£o de informa√ß√µes
            com gera√ß√£o de texto usando LLMs. Os componentes principais s√£o:
            
            1. Vector Database - armazena embeddings
            2. Retriever - busca documentos relevantes  
            3. Generator - LLM que gera respostas
            
            Vantagens: conhecimento atualizado, menos alucina√ß√µes, fontes transparentes.
            """,
            
            "python_tips.txt": """
            Python √© uma linguagem vers√°til para desenvolvimento. Dicas importantes:
            
            - Use list comprehensions para c√≥digo mais limpo
            - Aproveite decorators para funcionalidade cross-cutting
            - Implemente context managers com 'with'
            - Use type hints para melhor documenta√ß√£o
            - Prefira f-strings para formata√ß√£o de strings
            
            Exemplo: def greet(name: str) -> str: return f"Hello, {name}!"
            """,
            
            "hybrid_search.txt": """
            Hybrid search combina dense retrieval (embeddings sem√¢nticos) com sparse retrieval (BM25).
            
            Dense vectors capturam similaridade sem√¢ntica.
            Sparse vectors fazem matching exato de keywords.
            
            Qdrant 1.8.0 trouxe 16x improvement em sparse vector search.
            RRF (Reciprocal Rank Fusion) combina os resultados eficientemente.
            """
        }
        
        # Salvar documentos
        data_dir = Path("data/quick_start")
        data_dir.mkdir(parents=True, exist_ok=True)
        
        for filename, content in sample_docs.items():
            file_path = data_dir / filename
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(content.strip())
        
        print(f"‚úÖ Criados {len(sample_docs)} documentos")
    
    async def _quick_indexing(self):
        """
        Indexa√ß√£o r√°pida dos documentos
        """
        print("üîÑ Indexando documentos...")
        
        # Encontrar documentos
        data_dir = Path("data/quick_start")
        doc_paths = [str(p) for p in data_dir.glob("*.txt")]
        
        # Indexar
        stats = await self.indexing_pipeline.index_documents(doc_paths)
        
        print(f"‚úÖ Indexa√ß√£o conclu√≠da!")
        print(f"   üìä {stats['documents_processed']} documentos")
        print(f"   üìä {stats['chunks_created']} chunks")
        print(f"   ‚è±Ô∏è  {stats['indexing_time']:.2f}s")
    
    async def _test_searches(self):
        """
        Testa diferentes tipos de busca
        """
        print("üîç Testando buscas...")
        
        test_queries = [
            {
                "query": "O que √© RAG?",
                "description": "Query sem√¢ntica"
            },
            {
                "query": "Python fun√ß√£o exemplo c√≥digo",
                "description": "Query com keywords"
            },
            {
                "query": "Qdrant 1.8.0 sparse vectors performance",
                "description": "Query h√≠brida"
            }
        ]
        
        for i, test in enumerate(test_queries, 1):
            print(f"\n--- Teste {i}: {test['description']} ---")
            print(f"Query: '{test['query']}'")
            
            # Executar busca
            results = await self.retriever.retrieve(
                query=test['query'],
                limit=2,
                strategy="auto"
            )
            
            if results:
                top_result = results[0]
                print(f"‚úÖ Encontrado: {len(results)} resultados")
                print(f"   üéØ Score: {top_result.combined_score:.3f}")
                print(f"   üìÑ Trecho: {top_result.content[:100]}...")
            else:
                print("‚ùå Nenhum resultado encontrado")
    
    async def interactive_mode(self):
        """
        Modo interativo para testes
        """
        print("\nüéÆ Modo Interativo")
        print("=" * 30)
        print("Digite suas queries (ou 'quit' para sair)")
        
        while True:
            try:
                query = input("\nüîç Query: ").strip()
                
                if query.lower() in ['quit', 'exit', 'q']:
                    break
                
                if not query:
                    continue
                
                # Executar busca
                results = await self.retriever.retrieve(
                    query=query,
                    limit=3,
                    strategy="auto"
                )
                
                print(f"\nüìä Resultados: {len(results)}")
                
                for i, result in enumerate(results, 1):
                    print(f"\n--- Resultado {i} ---")
                    print(f"Score: {result.combined_score:.3f}")
                    print(f"M√©todo: {result.retrieval_method}")
                    print(f"Conte√∫do: {result.content[:200]}...")
                    
            except KeyboardInterrupt:
                break
            except Exception as e:
                print(f"‚ùå Erro: {e}")
        
        print("\nüëã Saindo do modo interativo")
    
    def show_next_steps(self):
        """
        Mostra pr√≥ximos passos
        """
        print("\nüéâ Quick Start Conclu√≠do!")
        print("=" * 40)
        print("\nüìö Pr√≥ximos passos:")
        print("1. üìñ Leia o guia completo: HYBRID_SEARCH_IMPLEMENTATION_GUIDE.md")
        print("2. üß™ Execute testes: python scripts/test_hybrid_performance.py")
        print("3. üéØ Veja exemplo completo: python examples/hybrid_search_example.py")
        print("4. ‚öôÔ∏è  Configure para produ√ß√£o: config/hybrid_search_config.yaml")
        
        print("\nüîó Recursos √∫teis:")
        print("- Documenta√ß√£o Qdrant: https://qdrant.tech/documentation/")
        print("- RAG Techniques: https://github.com/FareedKhan-dev/all-rag-techniques")
        print("- Qdrant 1.8.0: https://qdrant.tech/articles/qdrant-1.8.x/")

async def main():
    """
    Fun√ß√£o principal do quick start
    """
    print("üöÄ HYBRID SEARCH QUICK START")
    print("Qdrant 1.8.0 + Sparse Vectors + Dense Embeddings")
    print("=" * 60)
    
    quick_start = HybridSearchQuickStart()
    
    try:
        # Configurar sistema
        await quick_start.setup_system()
        
        # Executar demo
        await quick_start.quick_demo()
        
        # Modo interativo
        if len(sys.argv) > 1 and sys.argv[1] == "--interactive":
            await quick_start.interactive_mode()
        
        # Mostrar pr√≥ximos passos
        quick_start.show_next_steps()
        
    except Exception as e:
        logger.error(f"Erro no quick start: {e}")
        print(f"\n‚ùå Erro: {e}")
        print("\nüîß Solu√ß√µes poss√≠veis:")
        print("1. Verifique se OPENAI_API_KEY est√° configurada")
        print("2. Instale depend√™ncias: pip install -r requirements.txt")
        print("3. Verifique logs para mais detalhes")

if __name__ == "__main__":
    asyncio.run(main()) 