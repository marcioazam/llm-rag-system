"""
Exemplo Completo de Hybrid Search com Qdrant 1.8.0
Demonstra implementa√ß√£o de sparse + dense vectors para RAG avan√ßado
Performance: 16x improvement em sparse vector search
"""

import asyncio
import logging
from pathlib import Path
import sys
import time
from typing import List, Dict, Any

# Adicionar src ao path
sys.path.append(str(Path(__file__).parent.parent))

from src.retrieval.hybrid_indexing_pipeline import HybridIndexingPipeline
from src.retrieval.hybrid_retriever import HybridRetriever
from src.vectordb.hybrid_qdrant_store import HybridQdrantStore
from src.embeddings.sparse_vector_service import AdvancedSparseVectorService

# Configurar logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class HybridSearchDemo:
    """
    Demonstra√ß√£o completa do sistema de busca h√≠brida
    """
    
    def __init__(self):
        self.indexing_pipeline = HybridIndexingPipeline()
        self.retriever = HybridRetriever()
        
    async def run_complete_demo(self):
        """
        Executa demonstra√ß√£o completa do sistema h√≠brido
        """
        logger.info("üöÄ Iniciando demonstra√ß√£o de Hybrid Search com Qdrant 1.8.0")
        
        # 1. Preparar documentos de exemplo
        await self._prepare_sample_documents()
        
        # 2. Indexar documentos
        await self._index_documents()
        
        # 3. Demonstrar diferentes tipos de busca
        await self._demonstrate_search_strategies()
        
        # 4. Benchmark de performance
        await self._benchmark_performance()
        
        # 5. Mostrar estat√≠sticas
        await self._show_statistics()
        
        logger.info("‚úÖ Demonstra√ß√£o conclu√≠da!")
    
    async def _prepare_sample_documents(self):
        """
        Cria documentos de exemplo para demonstra√ß√£o
        """
        logger.info("üìÑ Preparando documentos de exemplo")
        
        # Criar diret√≥rio de exemplos se n√£o existir
        examples_dir = Path("data/examples")
        examples_dir.mkdir(parents=True, exist_ok=True)
        
        # Documentos de exemplo com diferentes caracter√≠sticas
        documents = {
            "python_basics.txt": """
            Python √© uma linguagem de programa√ß√£o de alto n√≠vel, interpretada e de prop√≥sito geral.
            Foi criada por Guido van Rossum em 1991. Python √© conhecida por sua sintaxe clara e leg√≠vel.
            
            Caracter√≠sticas principais:
            - Sintaxe simples e intuitiva
            - Tipagem din√¢mica
            - Interpretada (n√£o compilada)
            - Orientada a objetos
            - Suporte a m√∫ltiplos paradigmas
            
            Exemplo de c√≥digo Python:
            def hello_world():
                print("Hello, World!")
                return True
            
            Python √© amplamente utilizada em:
            - Desenvolvimento web (Django, Flask)
            - Ci√™ncia de dados (Pandas, NumPy)
            - Machine Learning (TensorFlow, PyTorch)
            - Automa√ß√£o e scripts
            """,
            
            "rag_systems.txt": """
            RAG (Retrieval-Augmented Generation) √© uma arquitetura que combina recupera√ß√£o de informa√ß√µes
            com gera√ß√£o de texto usando modelos de linguagem grandes (LLMs).
            
            Componentes principais de um sistema RAG:
            1. Vector Database - armazena embeddings de documentos
            2. Retriever - busca documentos relevantes
            3. Generator - LLM que gera respostas baseadas no contexto
            
            Tipos de busca em RAG:
            - Dense retrieval: usa embeddings sem√¢nticos
            - Sparse retrieval: usa keywords e BM25
            - Hybrid retrieval: combina dense + sparse
            
            Vantagens do RAG:
            - Conhecimento atualizado
            - Reduz alucina√ß√µes
            - Transpar√™ncia nas fontes
            - Escalabilidade
            """,
            
            "vector_databases.txt": """
            Vector databases s√£o sistemas especializados em armazenar e buscar vetores de alta dimensionalidade.
            
            Principais vector databases:
            - Qdrant: Rust-based, alta performance
            - Pinecone: Managed service
            - Weaviate: Open source com GraphQL
            - Chroma: Simples e local
            - Milvus: Distribu√≠do e escal√°vel
            
            Qdrant 1.8.0 introduziu melhorias significativas:
            - Sparse vectors com 16x performance improvement
            - CPU resource management
            - Melhor indexa√ß√£o para dados de texto
            
            Opera√ß√µes principais:
            - Upsert: inserir/atualizar vetores
            - Search: busca por similaridade
            - Filter: filtrar por metadata
            - Delete: remover vetores
            """,
            
            "machine_learning.txt": """
            Machine Learning √© um subcampo da intelig√™ncia artificial que permite que sistemas
            aprendam e melhorem automaticamente atrav√©s da experi√™ncia.
            
            Tipos de Machine Learning:
            1. Supervised Learning - aprendizado supervisionado
            2. Unsupervised Learning - aprendizado n√£o supervisionado  
            3. Reinforcement Learning - aprendizado por refor√ßo
            
            Algoritmos populares:
            - Linear Regression
            - Random Forest
            - Support Vector Machines
            - Neural Networks
            - K-Means Clustering
            
            Aplica√ß√µes:
            - Reconhecimento de imagem
            - Processamento de linguagem natural
            - Sistemas de recomenda√ß√£o
            - Detec√ß√£o de fraude
            - Carros aut√¥nomos
            """
        }
        
        # Salvar documentos
        for filename, content in documents.items():
            file_path = examples_dir / filename
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(content)
        
        logger.info(f"‚úÖ Criados {len(documents)} documentos de exemplo")
    
    async def _index_documents(self):
        """
        Indexa documentos usando o pipeline h√≠brido
        """
        logger.info("üîÑ Indexando documentos no pipeline h√≠brido")
        
        # Encontrar documentos
        examples_dir = Path("data/examples")
        document_paths = list(examples_dir.glob("*.txt"))
        
        if not document_paths:
            logger.error("‚ùå Nenhum documento encontrado para indexa√ß√£o")
            return
        
        # Indexar
        start_time = time.time()
        stats = await self.indexing_pipeline.index_documents([str(p) for p in document_paths])
        end_time = time.time()
        
        logger.info(f"‚úÖ Indexa√ß√£o conclu√≠da em {end_time - start_time:.2f}s")
        logger.info(f"üìä Estat√≠sticas: {stats}")
    
    async def _demonstrate_search_strategies(self):
        """
        Demonstra diferentes estrat√©gias de busca
        """
        logger.info("üîç Demonstrando estrat√©gias de busca")
        
        # Queries de teste
        test_queries = [
            {
                "query": "Como funciona Python?",
                "description": "Query sem√¢ntica - deve usar dense search",
                "expected_strategy": "semantic"
            },
            {
                "query": "fun√ß√£o print Python c√≥digo",
                "description": "Query por keywords - deve usar sparse search",
                "expected_strategy": "keyword"
            },
            {
                "query": "Qdrant 1.8.0 performance improvement",
                "description": "Query h√≠brida - deve usar busca combinada",
                "expected_strategy": "hybrid"
            },
            {
                "query": "machine learning algoritmos tipos",
                "description": "Query mista - deve usar estrat√©gia autom√°tica",
                "expected_strategy": "auto"
            }
        ]
        
        for i, test_case in enumerate(test_queries, 1):
            logger.info(f"\n--- Teste {i}: {test_case['description']} ---")
            logger.info(f"Query: '{test_case['query']}'")
            
            # Busca com estrat√©gia autom√°tica
            start_time = time.time()
            results = await self.retriever.retrieve(
                query=test_case['query'],
                limit=3,
                strategy="auto"
            )
            search_time = time.time() - start_time
            
            logger.info(f"‚è±Ô∏è  Tempo de busca: {search_time:.3f}s")
            logger.info(f"üìä Resultados encontrados: {len(results)}")
            
            # Mostrar top resultado
            if results:
                top_result = results[0]
                logger.info(f"üéØ Top resultado:")
                logger.info(f"   - Dense score: {top_result.dense_score:.3f}")
                logger.info(f"   - Sparse score: {top_result.sparse_score:.3f}")
                logger.info(f"   - Combined score: {top_result.combined_score:.3f}")
                logger.info(f"   - M√©todo: {top_result.retrieval_method}")
                logger.info(f"   - Explica√ß√£o: {top_result.query_match_explanation}")
                logger.info(f"   - Conte√∫do: {top_result.content[:200]}...")
    
    async def _benchmark_performance(self):
        """
        Executa benchmark de performance
        """
        logger.info("\nüèÜ Executando benchmark de performance")
        
        # Queries para benchmark
        benchmark_queries = [
            "Python programming language",
            "RAG system architecture",
            "vector database operations",
            "machine learning algorithms",
            "Qdrant sparse vectors",
            "dense retrieval embeddings",
            "hybrid search performance",
            "BM25 keyword matching"
        ]
        
        # Benchmark diferentes estrat√©gias
        strategies = ["dense_only", "sparse_only", "hybrid"]
        
        for strategy in strategies:
            logger.info(f"\n--- Benchmark: {strategy} ---")
            
            times = []
            total_results = 0
            
            for query in benchmark_queries:
                start_time = time.time()
                results = await self.retriever.retrieve(
                    query=query,
                    limit=5,
                    strategy=strategy,
                    use_reranking=False  # Sem reranking para benchmark puro
                )
                end_time = time.time()
                
                times.append(end_time - start_time)
                total_results += len(results)
            
            # Estat√≠sticas
            avg_time = sum(times) / len(times)
            min_time = min(times)
            max_time = max(times)
            avg_results = total_results / len(benchmark_queries)
            
            logger.info(f"‚è±Ô∏è  Tempo m√©dio: {avg_time:.3f}s")
            logger.info(f"‚è±Ô∏è  Tempo m√≠n/m√°x: {min_time:.3f}s / {max_time:.3f}s")
            logger.info(f"üìä Resultados m√©dios: {avg_results:.1f}")
    
    async def _show_statistics(self):
        """
        Mostra estat√≠sticas detalhadas do sistema
        """
        logger.info("\nüìà Estat√≠sticas do Sistema")
        
        # Estat√≠sticas do pipeline
        pipeline_stats = self.indexing_pipeline.get_stats()
        logger.info(f"üìä Pipeline Stats: {pipeline_stats}")
        
        # Estat√≠sticas do retriever
        retriever_metrics = self.retriever.get_metrics()
        logger.info(f"üîç Retriever Metrics: {retriever_metrics}")
        
        # Estat√≠sticas do vector store
        vector_store_info = await self.retriever.vector_store.get_collection_info()
        logger.info(f"üóÑÔ∏è  Vector Store Info: {vector_store_info}")

async def main():
    """
    Fun√ß√£o principal da demonstra√ß√£o
    """
    demo = HybridSearchDemo()
    await demo.run_complete_demo()

def run_interactive_demo():
    """
    Executa demo interativo
    """
    print("üöÄ Hybrid Search Demo - Qdrant 1.8.0")
    print("=====================================")
    
    retriever = HybridRetriever()
    
    while True:
        print("\nOp√ß√µes:")
        print("1. Buscar com estrat√©gia autom√°tica")
        print("2. Buscar apenas dense vectors")
        print("3. Buscar apenas sparse vectors")
        print("4. Buscar h√≠brido")
        print("5. Ver m√©tricas")
        print("6. Sair")
        
        choice = input("\nEscolha uma op√ß√£o (1-6): ").strip()
        
        if choice == "6":
            break
        elif choice == "5":
            metrics = retriever.get_metrics()
            print(f"\nüìä M√©tricas: {metrics}")
            continue
        
        query = input("Digite sua query: ").strip()
        if not query:
            continue
        
        strategy_map = {
            "1": "auto",
            "2": "dense_only", 
            "3": "sparse_only",
            "4": "hybrid"
        }
        
        strategy = strategy_map.get(choice, "auto")
        
        async def search():
            start_time = time.time()
            results = await retriever.retrieve(query, limit=3, strategy=strategy)
            end_time = time.time()
            
            print(f"\n‚è±Ô∏è  Tempo: {end_time - start_time:.3f}s")
            print(f"üìä Resultados: {len(results)}")
            
            for i, result in enumerate(results, 1):
                print(f"\n--- Resultado {i} ---")
                print(f"Dense: {result.dense_score:.3f} | Sparse: {result.sparse_score:.3f}")
                print(f"Combined: {result.combined_score:.3f}")
                print(f"M√©todo: {result.retrieval_method}")
                print(f"Conte√∫do: {result.content[:300]}...")
        
        asyncio.run(search())

if __name__ == "__main__":
    import sys
    
    if len(sys.argv) > 1 and sys.argv[1] == "--interactive":
        run_interactive_demo()
    else:
        asyncio.run(main()) 